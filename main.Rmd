---
title: "R Notebook"
output: html_notebook
---
# import data 
```{r}
install.packages('fUnitRoots')
```

```{r}
library('forecast')
library('dplyr')
library('zoo')
library('tseries')
library('fUnitRoots')
```


```{r}
data <- read.csv2('data/valeurs_mensuelles.csv')
data <- data[4:nrow(data),]
data <- data.frame(date = as.yearmon(data$Libellé),
                 x =as.numeric(data$Indice.CVS.CJO.de.la.production.industrielle..base.100.en.2021....Commerce.d.électricité..NAF.rév..2..niveau.classe..poste.35.14.))
x <- zoo(data$x, order.by = data$date)
```

# Part I
## question 1
 a développer mais : selon NAf rev 2
 Commerce d'électricité
Cette sous-classe comprend :
- la vente d'électricité au consommateur
- les activités des courtiers en courant électrique ou des agents qui organisent la vente d'électricité
via des systèmes de distribution de courant exploités par d'autres
- l'exploitation des échanges d'électricité et de capacité de transfert pour le courant électrique
Produits associés : 35.14.10

## question 2
Firstly we will graphically represent our serie and the differentiated serie of order 1.
```{r}
dx <- diff(x,1)
plot(cbind(x,dx))
```
At first, the serie seem to have a linear deterministic trend which does not seem to hold after 2010. The first difference of the serie seem stable around 0 and could be stationnary, we supose that the serie is I(1). To test this we will conduct a UR test.

given the look of the serie we can assume that its quadratic in time with positive coefficient in time and negative coefficient in the square of time. This is the case :
```{r}
summary(lm(x ~ index(x) + I(index(x)^2)))
summary(lm(x ~ index(x)))
```
We will then need ADF test with both non null intercept and non null trend. We now have to determine the number of lag that will be incorporated in our ADF test. For the test to be valid, the residuals must not be correlated,. We test that by using the Ljung-Box test of the null hypothesis of joint nullity of autocorrelations until a given order k (see TD4). we will do this test for $ k = 1 \dots 60 $ (5 years = 60 months).
```{r}
adf <- adfTest(dx, lag=0, type="ct")
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
Qtests(adf@test$lm$residual,60,length(adf@test$lm$coefficients))

```
The null hypothesis is rejected for all number of lag so the residuals are correlated. We will now choose the number of lag as the first integer such that with this Ljung-Box test the null hypothesis cannot be rejected until 60.
```{r}
adfLag <-function(series,kmax,type){ #ADF tests until no more autocorrelated residuals
k <- 0
noautocorr <- 0
while (noautocorr==0){

adf <- adfTest(series,lags=k,type=type)
pvals <- Qtests(adf@test$lm$residuals,24,fitdf=length(adf@test$lm$coefficients))[,2]
if (sum(pvals<0.05,na.rm=T) == 0) {
noautocorr <- 1}
k <- k + 1
}
return(k-1)
}
k <- suppressWarnings(adfLag(x,60,"ct"))
k
```
The Ljung-Box test gives us an adf with 21 lags.
```{r}
adf <- suppressWarnings(adfTest(x,lags=k,type='ct'))
adf
```
The null hypothesis of unit root is not rejected at 5% level. let's apply the same procedure to the first difference of the serie.
```{r}
k <- suppressWarnings(adfLag(dx,60,"ct"))
adf <- suppressWarnings(adfTest(dx,lags=k,type='ct'))
adf
```
The test reject the null hypothesis of unit root at 5% level so we will say that the first difference of the serie is stationary.
```{r}
plot(cbind(x,dx))
```
# Part II
From part1 we know that we will fit an ARIMA(p,1,q) model. To determine the parameter p, q we will determine maximum value of p and q and then use AIC or BIC to choose (p,q). We will then accept the model if its well-adjusted and valid, choose the model that is second according to AIC/ BIC minimzation if the model is either not well adjusted or not valid.

We plot the ACF plot to choose maximum q, we also plot the same plot with lag 0 removed to have a better read.

```{r}
par(mfrow=c(1,2))
acf <- acf(zoo(coredata(dx), order.by = seq_along(index(dx))), lag.max = 30, plot = TRUE)
acf_lags <- acf$lag[-1]
acf_vals <- acf$acf[-1]
n <- acf$n.used
conf <- qnorm((1 + 0.95) / 2) / sqrt(n)  # ~1.96 / sqrt(n)

# Plot
plot(acf_lags, acf_vals, type = "h", lwd = 2, xlab = "Lag", ylab = "ACF", 
     main = "ACF (Lag 0 removed)", ylim = c(min(acf_vals, -conf), max(acf_vals, conf)))
abline(h = 0, col = "gray")
abline(h = c(-conf, conf), col = "blue", lty = 2)
abs(acf$acf)> conf
```
We determine $q_{max} = 27$ however that is extremly high and if we try to fit an arima with q = 27 we wont be able to evaluate the parameter XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX le dire mieux mais en fait c'est qu'on as 400 point donc on peut pas faire des p ou q aussi grand XXXXXXXXXXXXXX so we choose $q_{max} = 13$
```{r}
par(mfrow=c(1,2))
pacf <- pacf(zoo(coredata(dx), order.by = seq_along(index(dx))), lag.max = 40, plot = TRUE)
pacf_lags <- pacf$lag[-1]
pacf_vals <- pacf$acf[-1]
n <- pacf$n.used
conf <- qnorm((1 + 0.95) / 2) / sqrt(n)  # ~1.96 / sqrt(n)

# Plot
plot(pacf_lags, pacf_vals, type = "h", lwd = 2, xlab = "Lag", ylab = "PACF", 
     main = "PACF (Lag 0 removed)", ylim = c(min(pacf_vals, -conf), max(pacf_vals, conf)))
abline(h = 0, col = "gray")
abline(h = c(-conf, conf), col = "blue", lty = 2)
abs(pacf$acf)> conf
```
We determine $p_{max} = 38$ however that is extremly high and if we try to fit an arima with p = 38 we wont be able to evaluate the parameter XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX le dire mieux mais en fait c'est qu'on as 400 point donc on peut pas faire des p ou q aussi grand XXXXXXXXXXXXXX so we choose $p_{max} = 13$

```{r}
pmax = 13
qmax = 13
mat <- matrix(NA,nrow=pmax+1,ncol=qmax+1) #empty matrix to fill
rownames(mat) <- paste0("p=",0:pmax) #renames lines
colnames(mat) <- paste0("q=",0:qmax) #renames columns
AICs <- mat #AIC matrix not filled non remplie
BICs <- mat #BIC matrix not filled non remplie
pqs <- expand.grid(0:pmax,0:qmax) #all possible combinations of p and q
for (row in 1:dim(pqs)[1]){ #loop for each (p,q)
p <- pqs[row,1] #gets p
q <- pqs[row,2] #gets q
estim <- try(arima(x,c(p,1,q),include.mean = F,optim.control = list(maxit = 50000))) #tries ARIMA estimation
AICs[p+1,q+1] <- if (class(estim)=="try-error") NA else estim$aic #assigns the AIC
BICs[p+1,q+1] <- if (class(estim)=="try-error") NA else BIC(estim) #assigns the BIC
}
BICs == min(BICs, na.rm = TRUE)
```
```{r}
AICs == min(AICs, na.rm = TRUE)
```
With BIC we choose p=q=1 and with AIC we chosse q =10 p = 12. We will select p=q=1 for simplicity's sake. Let's see if the model is well-adjusted and valid.


```{r}
arima111 <- arima(x,c(1,1,1),include.mean = F)
signif <- function(estim){
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))^2
return(rbind(coef,se,pval))
}
signif(arima111)
```
seeing p-value we reject null hypothesis, the coefficient ar1 and ma1 are non null -> the model is well adjusted.

```{r}
Qtests(arima111$residuals,24,fitdf=2)
```
the residuals are not correlated so the ARIMA(1,1,1) is valid.

XXXXXXXXXXXXXXXX a retravailler après: pour le model ARIMA(12,1,10) modèle pas well adjusted bcause of AR6,MA5,MA8, et pas valid car résidu autocorrélé lag = 23

```{r}
arima12110 <- arima(x,c(12,1,10),include.mean = F,optim.control = list(maxit = 50000))
signif <- function(estim){
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))^2
return(rbind(coef,se,pval))
}
signif(arima12110)
```

```{r}
Qtests(arima12110$residuals,24,fitdf=22)
```



XXXXXXXXXXXXX write the ARIMA model 
# Part III










# blabla explicatif  

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

